import {Record} from "./record";
import {Vector} from "./vector";

export declare interface Section {
	getId(): number;
	//PostPropertyMap::getOperationProperties(): PropertyMap;
	//optional< String > 	getStrategy ()
	getnumberOfRecords(): Integer;
	getRecord(id: Integer): Record;
	getJobId(): Integer;
	getPatternId(): Integer;
	getnumberOfPatternInstances(): Integer;
	isPatterned(): boolean;
	getChannel(): Integer;
	getForceToolChange(): boolean;
	isOptional(): boolean;
	getFirstCompensationOffset(): Integer;
	getTool(): Tool;
	getContent(): Integer;
	isMultiAxis(): boolean;
	getUnit(): Integer;
	getType(): Integer;
	getQuality(): Integer;
	getJetMode(): Integer;
	getTailstock(): boolean;
	getPartCatcher(): boolean;
	getSpindle(): Integer;
	getFeedMode(): Integer;
	getToolOrientation(): number;
	getWorkOrigin(): Vector;
	getWorkPlane(): Matrix;
	isXOriented(): boolean;
	isYOriented(): boolean;
	isZOriented(): boolean;
	isTopWorkPlane(): boolean;
	getGlobalWorkOrigin(): Vector;
	getGlobalWorkPlane(): Matrix;
	getToolAxis(): Integer;
	getWCSOrigin(): Vector;
	getWCSPlane(): Matrix;
	getDynamicWCSOrigin(): Vector;
	getDynamicWCSPlane(): Matrix;
	getFCSOrigin(): Vector;
	getFCSPlane(): Matrix;
	getModelOrigin(): Vector;
	getModelPlane(): Matrix;
	getWorkOffset(): Integer;
	getProbeWorkOffset(): Integer;
	getWCS(): String;
	getWCSIndex(): Integer;
	hasDynamicWorkOffset(): boolean;
	getDynamicWorkOffset(): Integer;
	getAxisSubstitution(): boolean;
	getAxisSubstitutionRadius(): number;
	getGlobalPosition(p: Vector): Vector;
	getWCSPosition(p: Vector): Vector;
	getSectionPosition(p: Vector): Vector;
	getMaximumSpindleSpeed(): number;
	getMaximumFeedrate(): number;
	getCuttingDistance(): number;
	getRapidDistance(): number;
	getMovements(): Integer;
	getCycleTime(): number;
	getnumberOfCyclePoints(): Integer;
	getZRange(): Range;
	getGlobalZRange(): Range;
	getGlobalRange(direction: Vector): Range;
	getBoundingBox(): BoundingBox;
	getGlobalBoundingBox(): BoundingBox;
	getOptimizedBoundingBox(machine: MachineConfiguration,abc: Vector): BoundingBox;
	isCuttingMotionAwayFromRotary(distance: number,tolerance: number): boolean;
	hasWellDefinedPosition(): boolean;
	getFirstPosition(): Vector;
	getInitialPosition(): Vector;
	getFinalPosition(): Vector;
	getInitialToolAxis(): Vector;
	getGlobalInitialToolAxis(): Vector;
	getInitialToolAxisABC(): Vector;
	getFinalToolAxis(): Vector;
	getFinalToolAxisABC(): Vector;
	getGlobalFinalToolAxis(): Vector;
	getInitialSpindleOn(): boolean;
	getInitialSpindleSpeed(): number;
	getFinalSpindleOn(): boolean;
	getFinalSpindleSpeed(): number;
	getMaximumTilt(): number;
	getLowerToolAxisABC(): Vector;
	getUpperToolAxisABC(): Vector;
	isOptimizedForMachine(): boolean;
	getOptimizedTCPMode(): Integer;
	hasParameter(name: String): boolean;
	getParameter(name: String,defaultValue: Value): Value;
	hasCycle(uri: String): boolean;
	hasAnyCycle(): boolean;
	getnumberOfCyclesWithId(uri: String): Integer;
	getnumberOfCycles(): Integer;
	getCycleId(index: Integer): String;
	getFirstCycle(): String;
	getLastCycle(): String;
	doesStartWithCycle(uri: String): boolean;
	doesEndWithCycle (String &_uri): boolean;//noexcept
	doesStartWithCycleIgnoringPositioning(uri: String): boolean;
	doesEndWithCycleIgnoringPositioning(uri: String): boolean;
	doesStrictCycle(uri: String): boolean;
	hasCycleParameter(index: Integer,name: String): boolean;
	getCycleParameter(index: Integer,name: String): Value;
	optimizeMachineAnglesByMachine (machine: MachineConfiguration,optimizeType: Integer): void;
	optimize3DPositionsByMachine (machine: MachineConfiguration,abc: Vector,optimizeType: Integer): void;
	getABCByPreference(machine: MachineConfiguration,orientation: Matrix,current: Vector,controllingAxis: Integer,type: Integer,options: Integer): Vector;
	doesToolpathFitWithinLimits(machine: MachineConfiguration,current: Vector): boolean;
	checkGroup(groups: Integer): boolean;
}

// ?([A-Z]+) ([A-Z]+)([,)])
//$2: $1$3